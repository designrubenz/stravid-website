<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">

  <title>CQRS and Event Sourcing Research by David Strauß</title>
  <meta name="description" content="Collection of thoughts, ideas and practices gained by working with event based systems.">

  <style type="text/css">
    body{font:18px/1.4 system-ui,sans-serif;margin:auto;max-width:40em;padding:0 1em}img,video{max-width:100%;height:auto}@media (max-width:375px){body{font-size:.9em}}@media (max-width:320px){body{font-size:.8em}}code,kbd,pre{font-family:SF Mono,Monaco,monospace}pre{background-color:#f8f8ff;font-size:.9em;overflow:auto;padding:1em}table{border-collapse:collapse;width:100%}td,th{padding:.5em;border:1px solid}
  </style>
</head>
<body>
  <h1>CQRS, Event Sourcing Research</h1>

  <p>
    In the freshly released time tracking area of Tedian a new error popped up in the event store implementation. Some interactions in the GUI sporadically caused <code>PG::UniqueViolation</code> errors in the event store.
  </p>

  <p>
    The event store is built upon PostgreSQL and uses an events table. One mechanism to ensure correctness is an unique constraint on <code>stream_name</code> and <code>position</code>. In plain english it means that within a stream of events every position can be only occupied once.
  </p>

  <p>
    As mentioned above this constraint was being violated sporadically. The cause were multiple commands, affecting the identical event stream, being submitted in rapid succession.
  </p>

  <p>
    The multithreaded application server accepted the commands simultaneously, invoked the command handlers and submitted the resulting events to the event store. Every so often two write transactions to the <code>events</code> table would overlap and cause the aforementioned error.
  </p>

  <p>
    This failure scenario immediately reminded me of optimistic locking. A feature that the event store supports but that is not used in this case. The commands are non-destructive and the order doesn't matter. But I think it's not the same problem.
  </p>

  <p>
    Optimistic locking is supposed to protect against scenarios where a command was handled and the resulting events published during the invocation of another command.
  </p>

  <p>
    This problem occurs because two writes to the same event stream happen at the same time. Which sounds the same but I think there is a subtle difference I can't articulate yet.
  </p>

  <p>
    How do I solve this?
  </p>

  <ol>
    <li>Implement a retry logic for such cases.</li>
    <li>Have a single event store writer.</li>
    <li>Ensure that commands are submitted sequentially.</li>
  </ol>

  <p>
    I went with option three for the time being but I don't know how to proceed.
  </p>

  <p>
    How does optimistic locking work with multiple events from one command if there is a clash with a different command that resulted also in multiple events?
  </p>

  <p>
    I think sending multiple commands at the same time is an anti-pattern. There should be a single bulk command to allow for recovery in failure scenarios.
  </p>

  <hr>

  <p>
    You will find the imprint and privacy policy linked in the next paragraph. They are there to be on the safe side. To spare you two clicks: This website doesn't use any analytics, cookies or other stuff and anonymises your IP in the web server log files.
  </p>

  <p>
    <a href="/sitemap.html">Sitemap</a> &middot; <a href="https://www.stravid.com/impressum">Impressum</a> &middot; <a href="https://www.stravid.com/datenschutzerklaerung">Datenschutzerklärung</a>
  </p>
</body>
</html>
